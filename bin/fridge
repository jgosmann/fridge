#!/usr/bin/env python

import argparse
import errno
import os
import os.path
import sys

from fridge.cas import ContentAddressableStorage


def add_blob(path):
    cas = ContentAddressableStorage(os.path.join('.fridge', 'blobs'))
    return cas.store(path)

def write_snapshot(snapshot):
    data = '\n'.join(
        '{} {}'.format(checksum, path) for checksum, path in snapshot)
    tmp_file = os.path.join('.fridge', 'tmp')
    with open(tmp_file, 'w') as f:
        f.write(data)

    cas = ContentAddressableStorage(os.path.join('.fridge', 'snapshots'))
    return cas.store(tmp_file)

def set_head(checksum):
    with open(os.path.join('.fridge', 'head'), 'w') as f:
        f.write(checksum)

def get_head():
    with open(os.path.join('.fridge', 'head')) as f:
        return f.read()

def read_snapshot(checksum):
    cas = ContentAddressableStorage(os.path.join('.fridge', 'snapshots'))
    with open(cas.get_path(checksum)) as f:
        for line in f:
            # FIXME more robust splitting?
            yield line.strip().split(' ', 1)

# TODO implement this and some other operations in a way that leaves the
# original state on error.
def checkout_blob(checksum, path):
    source_dir = os.path.join('.fridge', 'blobs', checksum[:2])
    source_name = checksum[2:]
    source_path = os.path.join(source_dir, source_name)
    try:
        os.symlink(source_path, path)
    except OSError as err:
        if err.errno == errno.EEXIST:
            if not os.path.samefile(source_path, path):
                pass  # Raise exception.
        else:
            raise


def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    # TODO add description and usage help
    parser = argparse.ArgumentParser()
    parser.add_argument('cmd', nargs=1, type=str)
    # FIXME what happens with an invalid cmd?
    parser.add_argument('argv', nargs=argparse.REMAINDER, type=str)
    args = parser.parse_args(argv)

    if 'init' in args.cmd:
        os.mkdir('.fridge')
    elif 'commit' in args.cmd:
        # FIXME repo dir shouldn't be fixed
        # FIXME what to do about symlinks?
        # TODO about errors?
        snapshot = []
        for dirpath, dirnames, filenames in os.walk('.'):
            if '.fridge' in dirnames:
                dirnames.remove('.fridge')
            for filename in filenames:
                path = os.path.join(dirpath, filename)
                checksum = add_blob(path)
                # FIXME file size, c and m time, access rights?
                snapshot.append((checksum, path))
        checksum = write_snapshot(snapshot)
        set_head(checksum)
    elif 'checkout' in args.cmd:
        head = get_head()
        snapshot = read_snapshot(head)
        for checksum, path in snapshot:
            checkout_blob(checksum, path)

if __name__ == '__main__':
    sys.exit(main())
